# DAuth - Generate and destroy user accounts just-in-time

![image](https://user-images.githubusercontent.com/67427045/214201859-4318014e-9ed1-40a7-ac8a-a44269d0ec7f.png)<br>

This repo introduces authentication WITHOUT A USER DATABASE or user/password storage and/or exchange.<br><br>
The idea is to log into a website via exchanging a token (QR Code) which is generated by the result of salting and hashing the name and passphrase.
<br>
This way the QR Code becomes the public key. If the QR Code gets decrypted, the result is just the hash of the salted name and passphrase.(useless)<br>
<br>
Only the owner of the name and the passphrase can re-create the exact same QR Code. (inside the app)<br>

# How does it work?

To do:
- salt, hash, pepper
- SHA-3 or Argon2 (for Argon2 i search for a client-side hashing repo thats not WASM)
- hide or show the QR code
- QR Code and/or hash match function

# Here is a first try (Work in progress)
![image](https://user-images.githubusercontent.com/67427045/214812508-e0c8ee14-82cb-48df-a19e-9ce333af9543.png)
<br>

### Course of action
1. At sign-up you generate a new QR Code(hash) from your name and a passphrase.<br><br>

2. The QR Code(hash) is for the period of the session connected with the user events/actions.

3. The first time you create a profile or create a post, this QR Code(hash) will be connected with your new profile or post<br>
```profile-creator: hash123 or post-creator: hash123``` (Pseudocode)<br><br>

This way, the profile or post "knows" who you are (which gives permission for edit/delete for instance)

```
// Pseudocode

{#if user = hash123}
editmode()

{#else}
watchmode()

{/if}
```

4. If the user logs out, the session gets destroyed, but not the created documents (profile, posts, messages)(own storage&sync-logic neccessary)

6. If the user returns, with the right combination of name and passphrase, he generates the exact same QR Code(hash). This gives him access to his created documents again.

# Advantages

- Your name and passphrase are neither locally nor online saved. Just in your head.
- No user-database necessary. The user basically generates himself on-demand, by simply logging in. And destroys himself by logging out.
- No database requests for permissions. The moment you load the post your permissions are set.

# How to improve security? (suggestions, Work in Progress)

- by hiding the QR-code
- https TLS! (against man in the middle attack)
- salting
- hash (SHA-3)
- encryption (AES256)
- encrypted transfer of the hash
- encrypted transfer of the QR Code (base64, webcrypto, other crypto-lib, SEA)
- instead of storing and or sending the QR Code you can just take the hash and generate the QR Code client-side again (also good for avatar or friend-connect for instance)
- mechanism to make sure only 1 QR-code each user<br>
<br>

# MUST read/watch
Fireship: https://youtu.be/NuyzuNBFWxQ (7 Cryptography Concepts EVERY Developer Should Know)<br>
<br>
Computerphile: https://youtu.be/8ZtInClXe1Q (How NOT to Store Passwords!) and https://youtu.be/b4b8ktEV4Bg (Hashing Algorithms and Security)<br>
<br>
https://stackoverflow.com/questions/549/the-definitive-guide-to-form-based-website-authentication/477578#477578 (The definitive guide to form-based website authentication)

# NPM

- npm install (install dependencies)
- npm run dev (run hot-reload dev environment)
- npm run build (edge-ready, vanillaJS, compressed)
<br>

![image](https://user-images.githubusercontent.com/67427045/213913807-464d737b-0bfb-4ece-a0d4-64cceac29671.png)<br>

# This is a concept inspired by [OPEN ID](https://en.wikipedia.org/wiki/OpenID) (Work in Progress)

### Short reminder of what OPEN ID is
The end user interacts with a relying party (such as a website) that provides an option to specify an OpenID for the purposes of authentication; an end user typically has previously registered an OpenID (e.g. ```alice.openid.example.org```) with an OpenID provider (e.g. ```openid.example.org```)<br>
<br>

### What did it inspire me to?
The problem in decentralization that comes up often is that "browsers can't listen to ports" which is pretty much the decision of the browser industry. So we are all locked in somewhat.<br>
<br>
"browsers can't listen to ports" means that browsers can send data to an adress and request something. But your browser (actually the device: computer, smartphone etc.) does not have a fixed address (the address switches), so your browser can't listen to incoming requests. (can't listen to ports, because there are no ports)<br>
<br>
This is the reason why you need a station in the middle (server, relay, signaling server etc.) When you and your chatpartner use Whatsapp, you both are connected to https://whatsapp.com, which manages your message exchange. A connected to whatsapp.com, B connected to whatsapp.com, we have line, signal.<br>
<br>
Today we use domains to make our servers, relays, signaling server, website, webapp etc. available to the public.<br>
Make them listen to that domain's "ports"<br>
<br>
But what if every person had a domain? Like everybody today is having a telephone-number...<br>
What if every browser had a domain? (browser to browser calls, browser sync, browser cms, browser whatnotelse...)

### Example
1. My domain is: myname.com
2. myname.com connects to a Gun relay, which is a decentralized back-end, a graph database.
3. My notebook, pc, and smartphone have an app, browser-extension, or webapp(myname.com), which connects regularly to myname.com to check for new data.
4. If you like to talk call myname.com, or message me on myname.com, or send whatever to myname.com (my all three devices "telephone-number")
5. This way every browser can listen to outside traffic. Ad-hoc sharing gets sweet as cake i imagine.
